(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.client = global.client || {}, global.client.js = factory()));
})(this, (function () { 'use strict';

    const FunctionComponent = 0;
    const HostRoot = 3;
    const HostComponent = 5;
    const HostText = 6;

    const NoFlags = 0b0000000;
    const Placement = 0b0000001;
    const Update = 0b0000010;
    const ChildDeletion = 0b0000100;
    const MutationMask = Placement | Update | ChildDeletion;

    class FiberNode {
        constructor(tag, pendingProps, key) {
            Object.defineProperty(this, "tag", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            Object.defineProperty(this, "stateNode", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            Object.defineProperty(this, "type", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "key", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "ref", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "return", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "sibling", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "child", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "index", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "updateQueue", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "pendingProps", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "memorizedProps", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            Object.defineProperty(this, "memorizedState", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // 双缓存机制下fiber节点指向的对应的另一个节点
            Object.defineProperty(this, "alternate", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // 副作用
            Object.defineProperty(this, "flags", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "subtreeFlags", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "deletions", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // 实例
            this.tag = tag;
            this.key = key;
            // HostComponent <div> ===> div Dom
            this.stateNode = null;
            // FunctionComponent ===> ()=>{}
            this.type = null;
            // 指向父fiberNode
            this.return = null;
            // 指向兄弟fiberNode
            this.sibling = null;
            // 指向子 fiberNode
            this.child = null;
            // 有多个同级的fiberNode index标识顺序
            this.index = 0;
            this.updateQueue = null;
            this.pendingProps = pendingProps;
            this.memorizedProps = null;
            this.memorizedState = null;
            // 与这个fiberNode相对应的fiberNode（双缓存机制）
            this.alternate = null;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
        }
    }
    class FiberRootNode {
        constructor(container, hostRootFiber) {
            Object.defineProperty(this, "container", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // 指向第一个FiberNode节点
            Object.defineProperty(this, "current", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            // 指向更新完成以后的第一个fiberNode节点，...双缓存技术
            Object.defineProperty(this, "finishedWork", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.container = container;
            this.current = hostRootFiber;
            hostRootFiber.stateNode = this;
            this.finishedWork = null;
        }
    }
    const createWorkInProgress = (current, pendingProps) => {
        let workInProgress = current.alternate;
        if (workInProgress === null) {
            // mount
            workInProgress = new FiberNode(current.tag, pendingProps, current.key);
            workInProgress.type = current.type;
            workInProgress.stateNode = current.stateNode;
            workInProgress.alternate = current;
            current.alternate = workInProgress;
        }
        else {
            // update
            workInProgress.pendingProps = pendingProps;
            workInProgress.flags = NoFlags;
            workInProgress.subtreeFlags = NoFlags;
            workInProgress.deletions = null;
        }
        workInProgress.child = current.child;
        workInProgress.type = current.type;
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.memorizedProps = current.memorizedProps;
        workInProgress.memorizedState = current.memorizedState;
        return workInProgress;
    };
    function createFiberFormElement(element) {
        const { type, key, props } = element;
        let fiberTag = FunctionComponent;
        if (typeof type === "string") {
            fiberTag = HostComponent;
        }
        else if (typeof type !== "function" && true) {
            console.warn("");
        }
        const fiber = new FiberNode(fiberTag, props, key);
        fiber.type = type;
        return fiber;
    }

    const createUpdate = (action) => {
        return {
            action,
        };
    };
    const createUpdateQueue = () => {
        return {
            shared: {
                pending: null,
            },
            dispatch: null,
        };
    };
    const enqueueUpdate = (updateQueue, update) => {
        updateQueue.shared.pending = update;
    };
    const processUpdateQueue = (baseState, pendingUpdate) => {
        const result = {
            memorizedState: baseState,
        };
        if (pendingUpdate !== null) {
            const action = pendingUpdate.action;
            if (action instanceof Function) {
                result.memorizedState = action(baseState);
            }
            else {
                result.memorizedState = action;
            }
        }
        return result;
    };

    const supportSymbol = typeof Symbol === "function" && Symbol.for;
    const REACT_ELEMNET_TYPE = supportSymbol
        ? Symbol.for("react.element")
        : 0xeac7;

    function childReconciler(shouldTrackEffects) {
        function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackEffects) {
                return;
            }
            else {
                const deletions = returnFiber.deletions;
                if (deletions === null) {
                    returnFiber.deletions = [childToDelete];
                    returnFiber.flags |= ChildDeletion;
                }
                else {
                    deletions === null || deletions === void 0 ? void 0 : deletions.push(childToDelete);
                }
            }
        }
        // 多节点=>单节点 diff时删除
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackEffects) {
                return;
            }
            let childToDelete = currentFirstChild;
            if (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
            }
        }
        function reconcileSingleElement(returnFiber, currentFiber, element) {
            // update阶段
            work: while (currentFiber !== null) {
                const key = element.key;
                if (currentFiber.key === key) {
                    if (element.$$typeof === REACT_ELEMNET_TYPE) {
                        if (currentFiber.type === element.type) {
                            // 可以复用
                            const existing = useFiber(currentFiber, element.props);
                            existing.return = returnFiber;
                            deleteRemainingChildren(returnFiber, currentFiber.sibling);
                            return existing;
                        }
                        deleteRemainingChildren(returnFiber, currentFiber);
                        break work;
                    }
                    else {
                        {
                            throw new Error("还未实现的react类型");
                        }
                    }
                }
                else {
                    // 删除旧的
                    deleteChild(returnFiber, currentFiber);
                    currentFiber = currentFiber.sibling;
                }
            }
            // 根据这个element创建fiber
            const fiber = createFiberFormElement(element);
            fiber.return = returnFiber;
            return fiber;
        }
        function reconcileSingleTextNode(returnFiber, currentFiber, content) {
            while (currentFiber !== null) {
                if (currentFiber.tag === HostText) {
                    // 类型没变可以复用
                    const existing = useFiber(currentFiber, { content });
                    existing.return = returnFiber;
                    deleteRemainingChildren(returnFiber, currentFiber.sibling);
                    return existing;
                }
                deleteChild(returnFiber, currentFiber);
                currentFiber = currentFiber.sibling;
            }
            const fiber = new FiberNode(HostText, { content }, null);
            fiber.return = returnFiber;
            return fiber;
        }
        function placeSingleChild(fiber) {
            if (shouldTrackEffects && fiber.alternate === null) {
                // 首屏渲染
                fiber.flags |= Placement;
                console.log("首屏渲染");
            }
            return fiber;
        }
        function reconcileChildrenArray(returnFiber, currentFirstFiberChild, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        newChild) {
            // 最后一个可复用fiber的current的index
            let lastPlacedIndex = 0;
            // 创建的最后一个fiber
            let lastNewFiber = null;
            // 创建的第一个fiber
            let firstNewFiber = null;
            // 1. 将current保存在map中
            const exiStingChildren = new Map();
            let current = currentFirstFiberChild;
            while (current !== null) {
                const keyToUse = current.key !== null ? current.key : current.index;
                exiStingChildren.set(keyToUse, current);
                current = current.sibling;
            }
            // 2. 遍历newChild
            for (let i = 0; i < newChild.length; i++) {
                // 是否可复用
                // 根据key从Map中获取current fiber , 如果不存在current fiber，则没有复用的可能
                // 接下来分情况讨论：
                // element是HostTest，current fiber是吗？
                // element是ReactElement， current fiber是吗？
                const after = newChild[i];
                const newFiber = updateFormMap(returnFiber, exiStingChildren, i, after);
                // xxxxx false null
                if (newFiber === null) {
                    continue;
                }
                //3. 标记移动还是插入
                /**
                 * 移动的判断依据：*****************
                 */
                newFiber.index = i;
                newFiber.return = returnFiber;
                if (lastNewFiber === null) {
                    lastNewFiber = newFiber;
                    firstNewFiber = newFiber;
                }
                else {
                    lastNewFiber.sibling = newFiber;
                    lastNewFiber = lastNewFiber.sibling;
                }
                if (!shouldTrackEffects) {
                    continue;
                }
                const current = newFiber.alternate;
                if (current !== null) {
                    const oldIndex = current.index;
                    console.log(oldIndex, i, "oldIndex");
                    if (oldIndex < lastPlacedIndex) {
                        console.log(1);
                        // 移动
                        newFiber.flags |= Placement;
                        continue;
                    }
                    else {
                        lastPlacedIndex = oldIndex;
                    }
                }
                else {
                    // mount
                    newFiber.flags |= Placement;
                }
            }
            // 4. 删除Map中剩下的标记为删除
            exiStingChildren.forEach((fiber) => {
                deleteChild(returnFiber, fiber);
            });
            return firstNewFiber;
        }
        function updateFormMap(returnFiber, exiStingChildren, index, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        element) {
            console.log(returnFiber, "returnFiber");
            const keyToUse = element.key !== null ? element.key : index;
            const before = exiStingChildren.get(keyToUse);
            if (typeof element === "string" || typeof element === "number") {
                if (before) {
                    if (before.tag === HostText) {
                        exiStingChildren.delete(keyToUse);
                        return useFiber(before, { content: element + "" });
                    }
                }
                return new FiberNode(HostText, { content: element + "" }, null);
            }
            if (typeof element === "object" && element !== null) {
                switch (element.$$typeof) {
                    case REACT_ELEMNET_TYPE:
                        if (before) {
                            console.log(before.type, element.type, before.type === element.type);
                            if (before.type === element.type) {
                                exiStingChildren.delete(keyToUse);
                                return useFiber(before, element.props);
                            }
                        }
                        return createFiberFormElement(element);
                }
                // todo
                if (Array.isArray(element) && true) {
                    console.warn("还未实现数组类型的children");
                }
            }
            return null;
        }
        return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
            if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                    case REACT_ELEMNET_TYPE:
                        return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                }
                // newChild是数组
                if (Array.isArray(newChild)) {
                    return reconcileChildrenArray(returnFiber, currentFiber, newChild);
                }
            }
            if (typeof newChild === "string" || typeof newChild === "number") {
                const child = placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
                return child;
            }
            if (currentFiber !== null) {
                // 兜底删除
                deleteRemainingChildren(returnFiber, currentFiber);
            }
            {
                console.warn("no 实现的reconcile类型");
            }
            return null;
        };
    }
    function useFiber(fiber, pendingProps) {
        const clone = createWorkInProgress(fiber, pendingProps);
        clone.index = 0;
        clone.sibling = null;
        return clone;
    }
    const reconcileChildFibers = childReconciler(true);
    const mountChildFibers = childReconciler(false);

    const currentDispatcher$1 = {
        current: null,
    };

    /* eslint-disable @typescript-eslint/no-explicit-any */
    // react
    const __SECRET_INTERNALS_DO_NOT_OR_YOU_BE_FILED = {
        currentDispatcher: currentDispatcher$1,
    };

    const internals = __SECRET_INTERNALS_DO_NOT_OR_YOU_BE_FILED;

    let currentlyRenderingFiber = null;
    // 正在处理的hooks
    let workInProgressHook = null;
    // 双缓存技术
    let currentHook = null;
    const { currentDispatcher } = internals;
    // 入口函数，在生成子fiber时调用
    function renderWithHooks(workInProgress) {
        currentlyRenderingFiber = workInProgress;
        workInProgress.memorizedState = null;
        // 取值
        const current = workInProgress.alternate;
        if (current !== null) {
            // update
            currentDispatcher.current = HooksDispatcherOnUpdate;
        }
        else {
            // 这里通过shared中转和react中的internal关联上
            currentDispatcher.current = HooksDispatcherOnMount;
        }
        const Component = workInProgress.type;
        const props = workInProgress.memorizedProps;
        const children = Component(props);
        // 重置操作
        currentlyRenderingFiber = null;
        currentHook = null;
        workInProgressHook = null;
        return children;
    }
    const HooksDispatcherOnMount = {
        useState: mountState,
    };
    const HooksDispatcherOnUpdate = {
        useState: updateState,
    };
    function mountState(initialState) {
        // 找到当前useState对应的hook数据
        const hook = mountWorkInProgressHook();
        let memorizedState;
        if (initialState instanceof Function) {
            memorizedState = initialState();
        }
        else {
            memorizedState = initialState;
        }
        const queue = createUpdateQueue();
        // 这一步是做什么的呢？
        hook.updateQueue = queue;
        hook.memorizedState = memorizedState;
        // 第三个参数action由用户使用useState时传
        const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        // 这是updateQueue新增的dispatch属性
        queue.dispatch = dispatch;
        return [memorizedState, dispatch];
    }
    function updateState() {
        // 找到当前useState对应的hook数据
        const hook = updateWorkInProgressHook();
        // 计算新state的逻辑
        const queue = hook.updateQueue;
        const pending = queue.shared.pending;
        if (pending !== null) {
            const { memorizedState } = processUpdateQueue(hook.memorizedState, pending);
            hook.memorizedState = memorizedState;
        }
        return [hook.memorizedState, queue.dispatch];
    }
    // 和updateContainer类似
    function dispatchSetState(fiber, updateQueue, action) {
        const update = createUpdate(action);
        // 把更新状态添加到更新队列
        enqueueUpdate(updateQueue, update);
        scheduleUpdateOnFiber(fiber);
    }
    function mountWorkInProgressHook() {
        const hook = {
            memorizedState: null,
            updateQueue: null,
            next: null,
        };
        if (workInProgressHook === null) {
            // MOUNT时且是第一个hook
            if (currentlyRenderingFiber === null) {
                // 没有在一个函数组件内调用hook
                throw new Error("请在函数组件内使用Hook");
            }
            else {
                workInProgressHook = hook;
                currentlyRenderingFiber.memorizedState = workInProgressHook;
            }
        }
        else {
            // mount时 后续的hook
            workInProgressHook.next = hook;
            workInProgressHook = hook;
        }
        return workInProgressHook;
    }
    function updateWorkInProgressHook() {
        // TODO render阶段触发的更新
        let nextCurrentHook = null;
        if (currentHook === null) {
            // 这是这个FC update时的第一个hook
            const current = currentlyRenderingFiber === null || currentlyRenderingFiber === void 0 ? void 0 : currentlyRenderingFiber.alternate;
            if (current !== null) {
                // update
                nextCurrentHook = current === null || current === void 0 ? void 0 : current.memorizedState;
            }
            else {
                // mount
                nextCurrentHook = null;
            }
        }
        else {
            // 这个FC update时 后续的hook（链表）
            nextCurrentHook = currentHook.next;
        }
        if (nextCurrentHook === null) {
            // mount/update u1 u2 u3
            // update       u1 u2 u3 u4
            throw new Error(`组件${currentlyRenderingFiber === null || currentlyRenderingFiber === void 0 ? void 0 : currentlyRenderingFiber.type}本次执行时比上一次执行多了一个hook`);
        }
        currentHook = nextCurrentHook;
        const newHook = {
            memorizedState: currentHook.memorizedState,
            updateQueue: currentHook.updateQueue,
            next: null,
        };
        if (workInProgressHook === null) {
            // MOUNT时且是第一个hook
            if (currentlyRenderingFiber === null) {
                // 没有在一个函数组件内调用hook
                throw new Error("请在函数组件内使用Hook");
            }
            else {
                workInProgressHook = newHook;
                currentlyRenderingFiber.memorizedState = workInProgressHook;
            }
        }
        else {
            // mount时 后续的hook
            workInProgressHook.next = newHook;
            workInProgressHook = newHook;
        }
        return workInProgressHook;
    }

    /**
     * @description 该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来
     */
    const beginWork = (WorkInProgress) => {
        switch (WorkInProgress.tag) {
            case HostRoot:
                /**
                 * @description 计算状态的最新值，创造子fiberNode
                 */
                return updateHostRoot(WorkInProgress);
            case HostComponent:
                /**
                 * @description 创造子fiberNode
                 */
                return updateHostComponent(WorkInProgress);
            case HostText:
                return null;
            // return updateHostText(workInProgress);
            case FunctionComponent:
                return updateFunctionComponent(WorkInProgress);
            default:
                {
                    console.warn("未实现的tag");
                }
                return null;
        }
    };
    function updateHostRoot(WorkInProgress) {
        // 获取初始状态
        const baseState = WorkInProgress.memorizedState;
        // 获取更新队列
        const updateQueue = WorkInProgress.updateQueue;
        // 获取判定的状态？
        const pending = updateQueue.shared.pending;
        // 清空绑定的状态
        updateQueue.shared.pending = null;
        // 消费状态
        const { memorizedState } = processUpdateQueue(baseState, pending);
        // 绑定新的状态
        WorkInProgress.memorizedState = memorizedState;
        // tag为hostRoot时 memorizedState就是子element
        const nextChildren = WorkInProgress.memorizedState;
        reconcileChildren(WorkInProgress, nextChildren);
        return WorkInProgress.child;
    }
    function updateHostComponent(workInProgress) {
        const nextProps = workInProgress.pendingProps;
        const nextChildren = nextProps.children;
        reconcileChildren(workInProgress, nextChildren);
        return workInProgress.child;
    }
    // function updateHostText(workInProgress: FiberNode) {
    //     const nextProps = workInProgress.pendingProps;
    //     const nextChildren = nextProps.children;
    //     reconcileChildren(workInProgress, nextChildren);
    //     return workInProgress.child;
    // }
    function updateFunctionComponent(workInProgress) {
        const nextChildren = renderWithHooks(workInProgress);
        reconcileChildren(workInProgress, nextChildren);
        return workInProgress.child;
    }
    function reconcileChildren(WorkInProgress, children) {
        const current = WorkInProgress.alternate;
        if (current !== null) {
            // update
            WorkInProgress.child = reconcileChildFibers(WorkInProgress, current.child, children);
        }
        else {
            WorkInProgress.child = mountChildFibers(WorkInProgress, null, children);
        }
    }

    const elementPropsKey = "__props";
    const validEventTypeList = ["click"];
    function updateFiberProps(node, props) {
        node[elementPropsKey] = props;
    }
    function initEvent(container, eventType) {
        if (!validEventTypeList.includes(eventType)) {
            console.warn("当前不支持==>", eventType);
        }
        {
            console.log("初始化事件：", eventType);
        }
        container.addEventListener(eventType, (e) => {
            dispatchEvent(container, eventType, e);
        });
    }
    function createSyntheticEvent(e) {
        const syntheticEvent = e;
        syntheticEvent.__stopPropagation = false;
        const originStopPropagation = e.stopPropagation;
        syntheticEvent.stopPropagation = () => {
            syntheticEvent.__stopPropagation = true;
            if (originStopPropagation) {
                originStopPropagation();
            }
        };
        return syntheticEvent;
    }
    function dispatchEvent(container, eventType, e) {
        const targetElement = e.target;
        if (targetElement === null) {
            return;
        }
        // 1. 收集沿途的事件
        const { capture, bubble } = collectPaths(targetElement, container, eventType);
        // 2. 构造合成事件
        const se = createSyntheticEvent(e);
        // 3. 遍历capture 捕获
        triggerEventFlow(capture, se);
        if (!se.__stopPropagation) {
            // 4. 遍历bubble 冒泡
            triggerEventFlow(bubble, se);
        }
    }
    function triggerEventFlow(paths, se) {
        for (let i = 0; i < paths.length; i++) {
            const callback = paths[i];
            callback.call(null, se);
            if (se.__stopPropagation) {
                break;
            }
        }
    }
    function getEventCallbackNameFormEventType(eventType) {
        return {
            click: ["onClickCapture", "onClick"],
        }[eventType];
    }
    function collectPaths(targetElement, container, eventType) {
        const paths = {
            capture: [],
            bubble: [],
        };
        while (targetElement && targetElement !== container) {
            // 收集的过程
            const elementProps = targetElement[elementPropsKey];
            if (elementProps) {
                const callbackNameList = getEventCallbackNameFormEventType(eventType);
                if (callbackNameList) {
                    callbackNameList.forEach((callbackName, index) => {
                        const eventCallback = elementProps[callbackName];
                        if (eventCallback) {
                            if (index === 0) {
                                paths.capture.unshift(eventCallback);
                            }
                            else {
                                paths.bubble.push(eventCallback);
                            }
                        }
                    });
                }
            }
            targetElement = targetElement.parentElement;
        }
        return paths;
    }

    function createInstance(type, props) {
        // todo 处理props
        const element = document.createElement(type);
        // 将事件回调保存在DOM中，创建DOM时
        updateFiberProps(element, props);
        return element;
    }
    function createTestInstance(content) {
        return document.createTextNode(content);
    }
    function appendInitialChild(parent, child) {
        parent.appendChild(child);
    }
    function removeChild(container, child) {
        container.removeChild(child);
    }
    const appendChildToContainer = appendInitialChild;
    function insertChildToContainer(child, container, before) {
        container.insertBefore(child, before);
    }

    let nextEffect = null;
    const commitMutationEffects = (finishedWork) => {
        nextEffect = finishedWork;
        while (nextEffect !== null) {
            // 向下遍历
            const child = nextEffect.child;
            if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
                child !== null) {
                // 子节点有可能存在subtreeFlags
                nextEffect = child;
            }
            else {
                // 找到底了或者没有subtreeFlags
                // 向上遍历
                up: while (nextEffect !== null) {
                    commitMutationEffectsOnFiber(nextEffect);
                    const sibling = nextEffect.sibling;
                    if (sibling !== null) {
                        nextEffect = sibling;
                        break up;
                    }
                    nextEffect = nextEffect.return;
                }
            }
        }
    };
    function commitMutationEffectsOnFiber(finishedWork) {
        const flags = finishedWork.flags;
        console.log((flags & Placement) !== NoFlags);
        if ((flags & Placement) !== NoFlags) {
            // 存在Placement操作
            commitPlacement(finishedWork);
            finishedWork.flags &= ~Placement;
        }
        if ((flags & Update) !== NoFlags) {
            commitUpdate(finishedWork);
            finishedWork.flags &= ~Update;
        }
        if ((flags & ChildDeletion) !== NoFlags) {
            const deletions = finishedWork.deletions;
            if (deletions !== null) {
                for (const childToDelete of deletions) {
                    commitDeletion(childToDelete);
                }
            }
            finishedWork.flags &= ~ChildDeletion;
        }
    }
    function commitPlacement(finishedWork) {
        // 需要知道父节点
        // 需要知道fiber对应的DOM节点
        {
            console.warn("执行placement操作");
        }
        // parent DOM
        const hostParent = getHostParent(finishedWork);
        // host sibling
        const sibling = getHostSibling(finishedWork);
        console.log(sibling);
        if (hostParent !== null) {
            // 找到finishedwork的dom append parent Dom中
            inertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, sibling);
        }
    }
    function getHostSibling(fiber) {
        let node = fiber;
        // eslint-disable-next-line no-constant-condition
        findSibling: while (true) {
            while (node.sibling === null) {
                const parent = node.return;
                if (parent === null ||
                    parent.tag === HostComponent ||
                    parent.tag === HostRoot) {
                    return null;
                }
                node = parent;
            }
            node.sibling.return = node.return;
            node = node.sibling;
            while (node.tag !== HostText && node.tag !== HostComponent) {
                // 向下遍历，找子孙节点
                if ((node.flags & Placement) !== NoFlags) {
                    // 节点是不稳定的
                    continue findSibling;
                }
                if (node.child === null) {
                    continue findSibling;
                }
                else {
                    node.child.return = node;
                    node = node.child;
                }
            }
            if ((node.flags & Placement) === NoFlags) {
                console.log(node.stateNode, "node.stateNode");
                return node.stateNode;
            }
        }
    }
    function commitDeletion(childToDelete) {
        let rootHostNode = null;
        commitNestedComponent(childToDelete, (unmountFiber) => {
            switch (unmountFiber.tag) {
                case HostComponent:
                    if (rootHostNode === null) {
                        rootHostNode = unmountFiber;
                    }
                    // Todo 解绑ref
                    return;
                case HostText:
                    if (rootHostNode === null) {
                        rootHostNode = unmountFiber;
                    }
                    return;
                case FunctionComponent:
                    // TODO useEffect unmount、解绑ref
                    break;
                default:
                    {
                        console.warn("未处理的unmount类型");
                    }
                    return;
            }
        });
        if (rootHostNode !== null) {
            const hostParent = getHostParent(childToDelete);
            if (hostParent !== null) {
                removeChild(hostParent, rootHostNode.stateNode);
            }
        }
        childToDelete.return = null;
        childToDelete.child = null;
        // 递归子树
    }
    function commitNestedComponent(root, onCommitUnMount) {
        // 深度优先遍历的过程
        let node = root;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            onCommitUnMount(node);
            // 向下遍历的过程
            if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
            }
            if (node === root) {
                return;
            }
            while (node.sibling === null) {
                if (node.return === null || node.return === root) {
                    return;
                }
                node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    function commitUpdate(finishedWork) {
        // 需要知道父节点
        // 需要知道fiber对应的DOM节点
        {
            console.warn("执行Update操作");
        }
        switch (finishedWork.tag) {
            case HostText:
                // eslint-disable-next-line no-case-declarations
                const text = finishedWork.memorizedProps.content;
                commitTextUpdate(finishedWork.stateNode, text);
                break;
            case HostComponent:
                updateFiberProps(finishedWork.stateNode, finishedWork.pendingProps);
                break;
            default:
                {
                    console.warn("未实现的update类型");
                }
                break;
        }
        const hostParent = getHostParent(finishedWork);
        if (hostParent !== null) {
            // 找到finishedwork的dom append parent Dom中
            inertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent);
        }
    }
    function commitTextUpdate(textInstance, content) {
        textInstance.textContent = content;
    }
    function getHostParent(fiber) {
        let parent = fiber.return;
        while (parent) {
            const parentTag = parent.tag;
            if (parentTag === HostComponent) {
                return parent.stateNode;
            }
            if (parentTag === HostRoot) {
                return parent.stateNode.container;
            }
            parent = parent.return;
        }
        {
            console.warn("未找到host parent");
        }
        return null;
    }
    function inertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, before) {
        if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
            if (before) {
                insertChildToContainer(finishedWork.stateNode, hostParent, before);
            }
            else {
                appendChildToContainer(hostParent, finishedWork.stateNode);
            }
            return;
        }
        const child = finishedWork.child;
        if (child !== null) {
            inertOrAppendPlacementNodeIntoContainer(child, hostParent);
            let sibling = child.sibling;
            while (sibling !== null) {
                inertOrAppendPlacementNodeIntoContainer(sibling, hostParent);
                sibling = sibling.sibling;
            }
        }
    }

    function markUpdate(fiber) {
        fiber.flags |= Update;
    }
    /**
     * @description 在“归”阶段会调用completeWork处理Fiber节点。
     */
    const completeWork = (WorkInProgress) => {
        const current = WorkInProgress.alternate;
        const newProps = WorkInProgress.pendingProps;
        switch (WorkInProgress.tag) {
            case HostComponent:
                if (current !== null && WorkInProgress.stateNode) {
                    // update
                    /**
                     * 1. 判断props是否变化 { onClick: f } => { onDoubleClick: f }
                     * 2. 如果变就需要打flag （Update）
                     */
                    // 这里应该时打flag（Update），而不是直接updateFiberProps---【todo】
                    updateFiberProps(WorkInProgress.stateNode, newProps);
                }
                else {
                    // mount时的 构建dom树
                    const instance = createInstance(WorkInProgress.type, newProps);
                    // 将Dom插入到树中
                    appendAllChildren(instance, WorkInProgress);
                    WorkInProgress.stateNode = instance;
                }
                bubbleProperties(WorkInProgress);
                break;
            case HostText:
                if (current !== null && WorkInProgress.stateNode) {
                    // update
                    const oldText = current.memorizedProps.content;
                    const newText = newProps.content;
                    if (oldText !== newText) {
                        markUpdate(WorkInProgress);
                    }
                }
                else {
                    // 构建dom树
                    const instance = createTestInstance(newProps.content);
                    WorkInProgress.stateNode = instance;
                }
                bubbleProperties(WorkInProgress);
                break;
            case HostRoot:
                bubbleProperties(WorkInProgress);
                break;
            case FunctionComponent:
                bubbleProperties(WorkInProgress);
                break;
        }
    };
    function appendAllChildren(parent, WorkInProgress) {
        //
        let node = WorkInProgress.child;
        while (node !== null) {
            if ((node === null || node === void 0 ? void 0 : node.tag) === HostComponent || (node === null || node === void 0 ? void 0 : node.tag) === HostText) {
                appendInitialChild(parent, node.stateNode);
            }
            else if ((node === null || node === void 0 ? void 0 : node.child) !== null) {
                node.child.return = node;
                node = node === null || node === void 0 ? void 0 : node.child;
                continue;
            }
            if (node === WorkInProgress) {
                return;
            }
            while (node.sibling === null) {
                if (node.return === null || node.return === WorkInProgress) {
                    return;
                }
                else {
                    node = node === null || node === void 0 ? void 0 : node.return;
                }
            }
            node.sibling.return = node.return;
            node = node.sibling;
        }
    }
    // 子fiber本身或者子fiber的子fiber有flag标记，则将此fiber的subtreeFlags标记为flag，
    // 因为completeWork是从下往上的过程，所以在这个阶段去标记flag最合适
    // 标记这个flag标记之后，commit阶段就可以根据flag和subtreeFlags决定是否向下变量这个fiber去创建真实dom
    function bubbleProperties(WorkInProgress) {
        let subtreeFlags = NoFlags;
        let child = WorkInProgress.child;
        while (child !== null) {
            subtreeFlags |= child.subtreeFlags;
            subtreeFlags |= child.flags;
            child.return = WorkInProgress;
            child = child.sibling;
        }
        WorkInProgress.subtreeFlags |= subtreeFlags;
    }

    let WorkInProgress;
    /**
     * @description 该函数用于准备一个新的栈，将 WorkInProgress 赋值为传入的 fiber 节点。
     */
    function prepareFreshStack(root) {
        WorkInProgress = createWorkInProgress(root.current, {});
    }
    /**
     * 在fibel中调度update
     */
    function scheduleUpdateOnFiber(fiber) {
        // 调度
        const root = markUpdateFromFiberToRoot(fiber);
        renderRoot(root);
    }
    /**
     * 遍历到根节点
     */
    function markUpdateFromFiberToRoot(fiber) {
        let node = fiber;
        let parent = node.return;
        while (parent !== null) {
            node = parent;
            parent = node.return;
        }
        if (node.tag === HostRoot) {
            return node.stateNode;
        }
        return null;
    }
    /**
     * @description 该函数是 Fiber 的入口函数，用于初始化并开始 Fiber 的工作循环。
     */
    function renderRoot(root) {
        // 初始化
        prepareFreshStack(root);
        do {
            try {
                workLoop();
                break;
            }
            catch (error) {
                {
                    console.warn("发生了错误");
                }
                WorkInProgress = null;
            }
            // eslint-disable-next-line no-constant-condition
        } while (true);
        const finishedWork = root.current.alternate;
        root.finishedWork = finishedWork;
        commitRoot(root);
    }
    function commitRoot(root) {
        const finishedWork = root.finishedWork;
        if (finishedWork === null) {
            return;
        }
        {
            console.warn("commit阶段开始", finishedWork);
        }
        // 重置
        root.finishedWork = null;
        // 判断是否存在三个子阶段需要执行的操作
        const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) != NoFlags;
        const rootHasEffect = (finishedWork.flags & MutationMask) != NoFlags;
        if (subtreeHasEffect || rootHasEffect) {
            // beforeMutation
            console.warn("beforeMutation");
            commitMutationEffects(finishedWork);
            // mutation
            console.warn("mutation");
            root.current = finishedWork;
            // layout
            console.warn("layout");
        }
        else {
            root.current = finishedWork;
        }
    }
    /**
     * @description 该函数是 Fiber 的工作循环，用于不断地执行任务，直到任务队列为空。
     */
    function workLoop() {
        while (WorkInProgress !== null) {
            performUnitOfWork(WorkInProgress);
        }
    }
    /**
     * @description 该函数是执行单元任务，用于执行 beginWork 并将 next 赋值给 WorkInProgress，如果 next 为空，则执行 completeUnitOfWork。
     */
    function performUnitOfWork(fiber) {
        const next = beginWork(fiber);
        fiber.memorizedProps = fiber.pendingProps;
        // fiber.memorizedProps = next?.memorizedProps ?? fiber.pendingProps;
        if (next === null) {
            completeUnitOfWork(fiber);
        }
        else {
            WorkInProgress = next;
        }
    }
    /**
     * @description 该函数是执行完成任务，用于执行 completeWork，然后将 WorkInProgress 赋值为下一个 sibling，如果没有 sibling，则将返回值赋值给 node.return，最后将 WorkInProgress 赋值为 null。
     */
    function completeUnitOfWork(fiber) {
        let node = fiber;
        do {
            completeWork(node);
            const sibling = node.sibling;
            if (sibling !== null) {
                WorkInProgress = sibling;
                return;
            }
            else {
                node = node.return;
                WorkInProgress = null;
            }
        } while (node !== null);
    }

    function createContainer(container) {
        const hostRootFiber = new FiberNode(HostRoot, {}, null);
        const root = new FiberRootNode(container, hostRootFiber);
        hostRootFiber.updateQueue = createUpdateQueue();
        return root;
    }
    function updateContainer(element, root) {
        const hostRootFiber = root.current;
        const update = createUpdate(element);
        enqueueUpdate(hostRootFiber.updateQueue, update);
        scheduleUpdateOnFiber(hostRootFiber);
        return Element;
    }

    // ReactDom.createRoot(root).render(jsx)
    function createRoot(container) {
        if (!container) {
            throw new Error("container不能为null");
        }
        const root = createContainer(container);
        return {
            render(element) {
                // 代理click事件
                initEvent(container, "click");
                updateContainer(element, root);
            },
        };
    }
    const $$mark = "dingjunjie";

    var ReactDom = /*#__PURE__*/Object.freeze({
        __proto__: null,
        $$mark: $$mark,
        createRoot: createRoot
    });

    return ReactDom;

}));
